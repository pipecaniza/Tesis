%% intro.tex

\chapter{Parser Combinators}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

En la programación funcional, una popular aproximación para construir parsers recursivos descendentes es modelar los parsers como funciones, y definir funciones de primer orden (o combinators) que implementan la contrucción de gramáticas como secuenciación, elección, y repetición.\cite{Hutton1996}

Los \emph{Parser Combinators} ocupan un lugar único en el campo del \emph{parsing}, pues hacen posible escribir expresiones que lucen como gramáticas, pero realmente describen los parsers de éstas gramáticas. La mayoría de los \emph{frameworks} de parsing más maduros suponen un preprocesamiento voluminoso, que lee la sintaxis, la analiza, y produce un codigo destino para la gramática de entrada. En contraste, una librería relativamente pequeña de \emph{Parsers Combinators} pueden alcanzar el poder de análisis aprovechando las estructuras del lenguaje.\cite{Swierstra2008}

\lstinputlisting[language=Haskell,caption=Definición del Parser.,label=cod-mod]{./Codes/ParserDefine.hs}

\section{Teoría}

Los \emph{Parser Combinators} son usados para escribir parsers que sean muy similares a la gramática de un lenguaje. Estos parsers son contruidos con lenguajes funcionales que proveen \emph{Lazyness}, \emph{High-order functions} (funciones de primer orden), listas, tipos de datos, y \emph{List Comprhensions} \cite{Jeuring2010}. Partiendo de la definición anterior, el concepto de \emph{parser combinators} existe en el mundo funcional, si un lenguaje de programación no soporta conceptos básicos funcionales como funciones de primer orden y polimorfismo, la implementación del mismo no sería plausible. Si bien el modelo computacional es independiete en la contrucción de la teoría computacional (ver siguiente capítulo), distintos modelos proveen distintos mecanismos de abstracción (algunos mas poderosos que otros), en teoría, cualquier problema computable (el parsing es uno de ellos) puede ser resuelto en cualquier modelo, pero cada modelo implica una implementación diferente, y la representación de cada modelo, es el lenguaje de programación mísmo, en otras palabras, el parsing puede ser resuleto en cualquier lenguaje de programación que provea estructuras suficientes para resolver el problema, pero en algunos lenguajes la aproximación por \emph{parser combinators} puede ser imposible.

En terminos generales, los \emph{Parser Combinators} consisten en la definición de parsers básicos, y componerlos entre sí para obtener como resultado un parser mucho mas complejo que sea capaz de identificar una gramática, su mayor ventaja es la forma directa y simple como se escriben los nuevos parsers partiendo de la gramática, es decir, los parsers son la gramática misma. Su naturalidad con el mundo funcional reside en las caracteristicas que comparten en su definición, tales como funciones, composición y polimorfismo. 

\section{Basic's Parsers}

\section{Parser Combinators}

\subsection{El Parser $<\$>$}
El parser combinator $<\$>$ toma como argumentos una función y un parser, el resultado es un parser que reconoce el mismo string de entrada que el parser original, pero \emph{postprocesando} el resultado usando el functor de entrada.\cite{Jeuring2010}. Este parser combinator tiene dos propósitos: proporcionar una manera fácil y efectiva de combinar los resultados de parser unidos por el operador $<*>$ (función sequenciadora), evitando anidamiento innecesario de túplas, también permite ser usado como una función semántica, que provee de flexibilidad a la combinación de parsers para modificar el tipo de retorno de los mismos, desde un arbol de sintaxis abstracta polimórfico hasta un valor o un string. 

El uso de $<\$>$ es generalmente sencillo, pero entender la definición de la función es dificil si no se tiene un conocimiento sólido en programación funcional. Este parser combinator es un claro ejemplo del pensamiento declarativo, una función muy compacta con una aplicación compleja. En primer lugar el \emph{Currying} es el núcleo de la definición de ésta función.

\begin{exmp}
	Sea $G_1$ una gramática válida sobre el lenguaje $L'$, y $G_1 \in LL(1)$.
	Donde $G_1$ está definido por:

	\begin{lstlisting}
	S -> '(' S ')' | e
	\end{lstlisting}
		
	$G_1$ no es una gramática recursiva por la izquierda y tampoco es ambigua.
	
	Utilizando la combinación de los parsers \emph{symbol} y del nuevo parser \emph{recursivo}, podemos escribir un parser utilizando la definición de la gramática. Como salída del proceso de parsing se espera un arbol de sintaxis abstracta.
	
	\lstinputlisting[language=Haskell,caption=Parser para la gramática $G_1$.,label=cod-mod]{./Codes/ParserS.hs}
	
	\emph{S} es la representación del arbol de sintaxis abstracta, su construcción es directa con la gramática, pero se omiten los terminales, en éste caso, $\forall x \in \{ `(', `)` \}$. Por la definición recursiva de la gramática, se usa en contructor \emph{Inside} que recibe el tipo de dato \emph{S}, lo que significa que hay parentesis tal como lo dice la gramática, y el contructor vacio \emph{Empty}, que se traduce al \emph{epsilon} de $G_1$.
	
	El nuevo parser que se está construyendo es \emph{parenthesis} con ayuda de los \emph{parser combinators}, éste recibe un [Char], y como resultado arroja [(S,[Char])]. Como se están usando varios parsers con el operador $<*>$ y no todos retornan S, debemos utilizar el operador $<\$>$ que servirá como pegamento para los diferentes parsers y para cambiar el resultado final con la función semántica.
	
	La función lambda está currificada, y puede ser reescrita como:
	
	\begin{lstlisting}[language=Haskell]
		(\_ -> (\x -> (\_ -> Inside x)))
	\end{lstlisting}

	Se observa de forma trivial, que dado la asociatividad por la derecha de las funciones currificadas, la aplicación de las mismas tiene una asociatividad por la izquierda.
	
	Toda la función lambda será el functor enviado a la función de primer orden $<\$>$, y el parser recibido será \emph{open}. Utilizando la definición de $<*>$, sabemos que el primer parser arrojará como resultado una función de $(a \to b)$, dado que la función $<\$>$ se aplico antes, el functor enviado a ésta tambien ya se aplico, pero parcialmente debido a que se reescribio descurrificandola, es decir, el resultado se podría expresar de la siguiente manera:
	
	\begin{lstlisting}[language=Haskell]
	[((\x -> (\_ -> Inside x))), ys]
	\end{lstlisting}
	
	De forma trivial se puede apreciar que la primer función lambda ya fue utilizada. Ésto garantiza la cohesión de tipos  con la función $<*>$. Así se seguirá aplicando la expresión lambda a lo largo de los parsers unidos por $<*>$. Cabe anotar, que el resultado que se espera es \emph{S}, es por ésto que la función lambda sólo utiliza el resultado del parser que está en segundo lugar, es decir, la llamada recursiva de \emph{parenthesis}, pues éste es el único parser que se está usando que retorna el valor \emph{S}.
	
	\begin{lstlisting}[language=Haskell, caption=Ejemplo de la utilización del parser en GHCi]
	*> parenthesis "((()))"
	   [(Inside(Inside(Inside Empty)), ""), (Empty,"((()))")]
	\end{lstlisting}
	
	Nótese que el parser intenta realizar la aplicación de todas las maneras posibles, lo cuál es obvio por su naturaleza recursiva, el segundo arbol es descartado pues no logra completar el análisis hasta el final.\\
	
	Con el anterior parser se puede reconocer la gramática $G_1$, y arrojará como resultado el arbol de sintaxis abstracta del mísmo. Nótese lo corto y directo que és el código, tan sólo modificando el contructor \emph{Inside} agregandole otra \emph{S}, agregando otra variable de entrada a la función lambda, y agregando otra llamada recursiva al parser \emph{parenthesis} luego del parser \emph{close}, será posible realizar el análisis sintáctico de la siguiente gramática:
	
	\begin{lstlisting}
	S -> '(' S ')' S | e
	\end{lstlisting}
	
\end{exmp}

\section{Parser Combinators E-BNF}
	
\section{Parsing funcional}




