%% intro.tex

\begin{conclusiones}
	%Creación de PC en C++
	Los \emph{Parser Combinators} no son más que una forma elegante y poderosa de resolver el problema del \emph{parsing}, éstos son implementables en el paradigma imperativo, sí y sólo sí el lenguaje soporta las características necesarias para llevar a cabo la implementación. Cómo se puede observar en el capítulo anterior, programar una librería funcional en un lenguaje imperativo supone un re-diseño no trivial, ésto incluso en un lenguaje como \emph{C++} que permite un gran número de abstracciones funcionales. 
	
	La implementación de los \emph{Parser Combinators} anteriormente expuestos es la primera solución en el universo imperativo aferrada totalmente a la teoría descrita en el universo funcional de dichos parsers. Si bien ya existen \emph{parser combinators} en lenguajes imperativos, todos han sido implementados con un esquema orientado a objetos, alejándose totalmente de la teoría, y tan sólo exponiendo una interface, así pues, se genera el mismo problema planteado al inicio sobre las librerías de parsing. Los parsers desarrollados en el universo imperativo pueden mejorarse mucho más, pero esto es el inicio de una librería que permitirá a los programadores crear analizadores sintácticos limpios y sencillos sin tener que profundizar demasiado en el paradigma funciona; puede ser usado tanto en la academia como en la implementación de compiladores robustos.	
	
	
	Los \emph{parser combinators sobre un lenguaje imperativo} descritos en el anterior capítulo no constituyen la respuesta a la pregunta de la interacción entre el modelo funcional e imperativo. \emph{C++} permite una gran cantidad de mecanismos de abstracción que hacen posible escribir código con expresividad funcional, si no fuera así, implementar la librería se volvería un problema inmanejable.
	
	La programación funcional en una máquina imperativa, con la arquitectura \textsc{Von Neumann}, es una \emph{ilusión}, el compilador es el encargado de transformar el código funcional en código imperativo. Si la tesis \emph{CT} es cierta, debe existir alguna civilización alienígena que haya desarrollado una máquina basada en una arquitectura funcional, en la cuál el código imperativo será traducido a su homologo funcional. Lo anterior implica que para el estudio de dichos ``universos" se deben utilizar conceptos abstractos y no implementaciones de los modelos.
	%Modelos computacionales diferentes puntos de vista
	
	Definir la teoría desde la cuál se estudiarán los modelos computacionales es crucial, pues cada una cambia enormemente la percepción de los mismos; desde un punto de vista de lenguajes se pueden estudiar como paradigmas, simplemente una forma de resolver un problema variando su expresividad. Desde compiladores se entienden como modelos de computo con sintaxis y semántica definida y que el uno puede ser traducido al otro. Desde teoría computacional se entienden como modelos de cómputo formalmente definidos, los cuales son la base abstracta para la implementación de una computadora. Ahora bien, se sabe que ambos modelos son emulables entre ellos, es implícita su equivalencia de poder de cómputo por la teoría de emulación, se sabe que son la base para la implementación del computador y de los paradigmas de programación, pero la investigación de estos modelos como entidades abstractas y disyuntas es casi nula, no existe un resultado concreto de la interacción entre ambos, de las estructuras que los separan y los conectan, aspectos filosóficos y profundos está aún fuera de nuestro conocimiento.
		
	Esta tésis parte de la concepción de los modelos computacionales como algo más que paradigmas, lenguajes o definiciones formales de los mismos; durante su elaboración se ha hablado de ``universos de cómputo", estos encierran todo el modelo, sus interacciones y demás elementos abstractos que posee. Puede que dicha concepción permita expandir la teoría en múltiples direcciones. Surgen innumerables incógnitas, ¿realmente lo modelos computacionales son más grandes y poseen interacciones más complejas de las que conocemos?, ¿qué efecto causará la definición de dichas interacciones en la teoría computacional?, ¿qué interacciones pueden surgir con un modelo de computo cuántico?
	
	Matemáticamente podríamos conjeturar que de ser posible construir las categorías 
	$\mathfrak{I}$ de lenguajes imperativos y $\mathfrak{F}$ de lenguajes funcionales, restrictas 
	a los universos imperativos y funcionales puros respectivamente, ¿Será posible hallar los 	
	functores e isomorfismos que hagan de ellas categorías equivalentes? ¿Será la respuesta hallada 
	en la teoría cuántica? ¿O será acaso que son categorías duales y siempre las hemos tratado
	como diferentes por no conocer teorías más avanzadas?
\end{conclusiones}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
